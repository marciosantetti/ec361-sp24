<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>.b[More exponential smoothing models]</title>
    <meta charset="utf-8" />
    <meta name="author" content="Prof. Santetti" />
    <script src="008-ets-2_files/header-attrs/header-attrs.js"></script>
    <link href="008-ets-2_files/remark-css/default.css" rel="stylesheet" />
    <link href="008-ets-2_files/remark-css/metropolis.css" rel="stylesheet" />
    <link href="008-ets-2_files/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="skid-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# .b[More exponential smoothing models]
]
.subtitle[
## .b[.green[EC 361–001]]
]
.author[
### Prof. Santetti
]
.date[
### Spring 2024
]

---












# Materials

&lt;br&gt;&lt;br&gt;

.b[Required readings]:

&lt;br&gt;


  - [`Hyndman &amp; Athanasopoulos, ch. 8`](https://otexts.com/fpp3/holt-winters.html)
  
    - sections 8.3&amp;mdash;8.7.
    


---
class: inverse, middle

# Motivation


---

# Motivation

&lt;br&gt;


Last time, we were introduced to .hi-red[exponential smoothing].

--

&lt;br&gt;

Recall that its .hi[main idea] comprises using .hi-blue[weighted averages], balancing out the *relative importance* of more recent and older observations.

--

&lt;br&gt;

Now, we move on by incorporating .hi-slate[seasonality] into exponential smoothing methods.


---
class: inverse, middle

# Exponential smoothing with seasonality


---

# Exponential smoothing with seasonality

As we are trying to incorporate more .hi-red[features] into our models, exponential smoothing methods have to include additional .hi-blue[parameters] and .hi-slate[equations].

--

There are .hi-red[two variations] to this method that differ in the .hi-slate[nature] of the seasonal component:

  - The *additive*;
  
  - And the *multiplicative* methods.


--

&lt;br&gt;



The .hi-red[additive] method is preferred when the seasonal variations are .hi-blue[roughly constant] through the series.

--

The .hi-blue[multiplicative] method is preferred when the seasonal variations are .hi-slate[changing] proportional to the level of the series.






---

# Exponential smoothing with seasonality

Let us start with the .hi[additive] method.

--

The .hi-slate[component form] looks like the following:

&lt;br&gt;


$$
`\begin{aligned}
\text{Forecast equation:} \ \  \hat{y}_{t+h|t} = \ell_t + hb_t + s_{t+h-m(k+1)}
\end{aligned}`
$$

$$
`\begin{aligned}
\text{Level equation:} \ \ \ell_t = \alpha (y_t - s_{t-m}) + (1-\alpha)(\ell_{t-1} + b_{t-1})
\end{aligned}`
$$

$$
`\begin{aligned}
\text{Trend equation:} \ \ b_t = \beta^*(\ell_t - \ell_{t-1}) + (1-\beta^*) b_{t-1}
\end{aligned}`
$$
$$
`\begin{aligned}
\text{Seasonal equation:} \ \ s_t = \gamma(y_t - \ell_{t-1} - b_{t-1}) + (1-\gamma)s_{t-m}
\end{aligned}`
$$

&lt;br&gt;&lt;br&gt;

where *m* denotes the period of seasonality.

---

# Exponential smoothing with seasonality

Then, for .hi-slate[multiplicative] seasonality, we have:

&lt;br&gt;&lt;br&gt;


$$
`\begin{aligned}
\text{Forecast equation:} \ \  \hat{y}_{t+h|t} = (\ell_t + hb_t)s_{t+h-m(k+1)}
\end{aligned}`
$$

$$
`\begin{aligned}
\text{Level equation:} \ \ \ell_t = \alpha \dfrac{y_t}{s_{t-m}} + (1-\alpha)(\ell_{t-1} + b_{t-1})
\end{aligned}`
$$

$$
`\begin{aligned}
\text{Trend equation:} \ \ b_t = \beta^*(\ell_t - \ell_{t-1}) + (1-\beta^*) b_{t-1}
\end{aligned}`
$$

$$
`\begin{aligned}
\text{Seasonal equation:} \ \ s_t = \gamma \dfrac{y_t}{(\ell_{t-1} + b_{t-1})} + (1-\gamma)s_{t-m}
\end{aligned}`
$$


---

# Exponential smoothing with seasonality


&lt;br&gt;&lt;br&gt;&lt;br&gt;

Regardless of the method, we may also allow for a .hi[damped trend], as we have seen in the previous lecture.



---
class: inverse, middle

# An example

---

# An example

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-1-1.svg" style="display: block; margin: auto;" /&gt;



---

# An example



```r
air_season_A_fit &lt;- air_ts |&gt; 
  model(additive_method = ETS(passengers ~ error("A") + trend("A") + season("A")))

air_season_A_fit |&gt; 
  report()
```

```
#&gt; Series: passengers 
#&gt; Model: ETS(A,A,A) 
#&gt;   Smoothing parameters:
#&gt;     alpha = 0.9934804 
#&gt;     beta  = 0.0001911792 
#&gt;     gamma = 0.0005800325 
#&gt; 
#&gt;   Initial states:
#&gt;      l[0]   b[0]      s[0]     s[-1]     s[-2]    s[-3]   s[-4]    s[-5]    s[-6]    s[-7]     s[-8]    s[-9]    s[-10]    s[-11]
#&gt;  120.9608 1.3934 -29.18157 -54.38417 -20.71687 15.07266 65.1554 66.18464 33.58223 -4.23203 -8.094607 -3.82047 -34.33642 -25.22879
#&gt; 
#&gt;   sigma^2:  325.697
#&gt; 
#&gt;      AIC     AICc      BIC 
#&gt; 1565.872 1570.729 1616.359
```



---

# An example

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-3-1.svg" style="display: block; margin: auto;" /&gt;

---

# An example



```r
air_season_M_fit &lt;- air_ts |&gt; 
  model(additive_method = ETS(passengers ~ error("M") + trend("A") + season("M")))

air_season_M_fit |&gt; 
  report()
```

```
#&gt; Series: passengers 
#&gt; Model: ETS(M,A,M) 
#&gt;   Smoothing parameters:
#&gt;     alpha = 0.3949969 
#&gt;     beta  = 0.01070044 
#&gt;     gamma = 0.3995392 
#&gt; 
#&gt;   Initial states:
#&gt;      l[0]     b[0]      s[0]     s[-1]    s[-2]    s[-3]    s[-4]    s[-5]    s[-6]     s[-7]    s[-8]    s[-9]    s[-10]    s[-11]
#&gt;  122.3754 1.107367 0.9000411 0.7826691 0.901368 1.047618 1.153707 1.183031 1.083995 0.9786589 1.033162 1.080757 0.9522479 0.9027453
#&gt; 
#&gt;   sigma^2:  0.0016
#&gt; 
#&gt;      AIC     AICc      BIC 
#&gt; 1398.807 1403.664 1449.294
```



---

# An example

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-5-1.svg" style="display: block; margin: auto;" /&gt;


---

# An example


```r
air_season_A_fc &lt;- air_season_A_fit |&gt; 
  forecast(h = 24)

air_season_M_fc &lt;- air_season_M_fit |&gt; 
  forecast(h = 24)
```



---

# An example

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-7-1.svg" style="display: block; margin: auto;" /&gt;


---

# An example

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-8-1.svg" style="display: block; margin: auto;" /&gt;



---
class: inverse, middle

# ETS taxonomy

---

# ETS taxonomy

As you may have noticed, different .hi-red[variations] of exponential smoothing are possible.

--

It all *depends on* the features we would like to explore from our data, and also whether these features (especially .hi-red[seasonality]) behaves in a *constant* or *non-constant* way.

--

Thus, it is possible to develop a .hi-blue[taxonomy] of exponential smoothing methods:

.center[
&lt;img src="ets-table.png", width = "70%"&gt;
]


--

The textbook also includes all *mathematical expressions* for each model's .hi-slate[component form].

---
class: inverse, middle

# Further thoughts

---

# Further thoughts

The exponential smoothing methods we have studied so far only produce .hi-blue[point forecasts].

--

The main issue concerning this fact is that these methods do not deliver .hi-red[prediction intervals].

--

This way, exponential smoothing .hi-slate[methods] are not the same as .hi[statistical models].


--

&lt;br&gt;

&gt; *A statistical model is a stochastic (or random) data generating process that can produce an entire forecast distribution.*

---

# Further thoughts

Given that we need a .hi-red[forecast distribution] in order to produce a .hi-slate[full forecast], we need to specify the .hi[stochastic] part of our methods.

--

Recall, from a few lectures ago, our definition of .hi-red[forecast errors]:

--

&lt;br&gt;

&gt; A .hi-red[forecast error] is the difference between an *observed* value and its *forecast*.

---

# Further thoughts

&lt;br&gt;

Formally, 

$$
`\begin{aligned}
e_{T+h} = y_{T+h} - \hat{y}_{T+h \ |\ T}
\end{aligned}`
$$

--

&lt;br&gt;

Coming back to .hi-slate[Simple Exponential Smoothing] (SES) methods, we can turn the component form into a statistical model:

$$
`\begin{aligned}
y_t = \ell_{t-1} + \varepsilon_t
\end{aligned}`
$$

$$
`\begin{aligned}
\ell_t = \ell_{t-1} + \alpha \varepsilon_t
\end{aligned}`
$$

where `\(\varepsilon_t \sim \mathcal{N}(0, \sigma^2)\)`.




--


The same "*error correction*" approach can be adopted for the other exponential smoothing methods.





---
class: inverse, middle

# Model selection

---

# Model selection

Models estimated via exponential smoothing have .hi-blue[36 possible variations], depending on how we specify its .b[E]rror, .b[T]rend, and .b[S]easonal components.

--

  - *But which one should we choose*?


--

A good .hi-red[starting point] is estimating the simplest possible model, accounting for the presence of .hi-slate[each feature] (or lack thereof).


---

# Model selection


&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-9-1.svg" style="display: block; margin: auto;" /&gt;

---
class: clear




```r
air_season_A_fit |&gt; 
  components() |&gt; 
  autoplot()
```

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-10-1.svg" style="display: block; margin: auto;" /&gt;


---
class: clear




```r
air_season_M_fit |&gt; 
  components() |&gt; 
  autoplot()
```

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-11-1.svg" style="display: block; margin: auto;" /&gt;




---

# Model selection

&lt;br&gt;

When errors are of a .hi-red[multiplicative] nature, simply minimizing the squared residuals is not sufficient for for model esimation.

--

Thus, a better approach is .hi[Maximum Likelihood] (ML).

--

&lt;br&gt;

Maximum Likelihood implies that, given the model we have chosen, what is the probability of obtaining the data we observe (*y&lt;sub&gt;t&lt;/sub&gt;*)?

--

  - Thus, a *large likelihood* is associated with a *good model*. 
  
---

# Model selection

Based on Maximum Likelihood, ETS models can make use of so-called .hi-slate[information criteria] for model comparison and selection.

--

One of them is the .hi-red[Akaike Information Criterion (AIC):]

$$
`\begin{aligned}
\text{AIC} = -2 \text{log}(L) + 2k
\end{aligned}`
$$

--

where *L* is the likelihood of the model and *k* is the total number of *parameters* and *initial states* that have been estimated (including the residual variance).

--

&lt;br&gt;

For smaller samples, an alternative measure is the .hi-slate[corrected AIC (AIC&lt;sub&gt;c&lt;/sub&gt;)]:

$$
`\begin{aligned}
\text{AIC}_{\text{c}} = \text{AIC} + \dfrac{2k(k+1)}{T-k-1}
\end{aligned}`
$$

---

# Model selection

Out of the 36 possible variations of ETS models, three of them usually produce .hi-slate[numerically unstable] estimations:

  1. ETS(A, N, M);
  2. ETS(A, A, M);
  3. ETS(A, A&lt;sub&gt;d&lt;/sub&gt;, M).
  
  
--

&lt;br&gt;

Therefore, the above models are hardly used in practice.

--

Models with .hi-blue[multiplicative errors] are useful when the data are .hi-red[strictly positive], but are .hi-slate[not] numerically stable when the data contain *zeros* or *negative values*. 

---

# Model selection

.pull-left[

```r
air_season_A_fit |&gt; 
  report()
```

```
#&gt; Series: passengers 
#&gt; Model: ETS(A,A,A) 
#&gt;   Smoothing parameters:
#&gt;     alpha = 0.9934804 
#&gt;     beta  = 0.0001911792 
#&gt;     gamma = 0.0005800325 
#&gt; 
#&gt;   Initial states:
#&gt;      l[0]   b[0]      s[0]     s[-1]     s[-2]    s[-3]   s[-4]    s[-5]    s[-6]    s[-7]     s[-8]    s[-9]    s[-10]    s[-11]
#&gt;  120.9608 1.3934 -29.18157 -54.38417 -20.71687 15.07266 65.1554 66.18464 33.58223 -4.23203 -8.094607 -3.82047 -34.33642 -25.22879
#&gt; 
#&gt;   sigma^2:  325.697
#&gt; 
#&gt;      AIC     AICc      BIC 
#&gt; 1565.872 1570.729 1616.359
```
]

.pull-right[

```r
air_season_M_fit |&gt; 
  report()
```

```
#&gt; Series: passengers 
#&gt; Model: ETS(M,A,M) 
#&gt;   Smoothing parameters:
#&gt;     alpha = 0.3949969 
#&gt;     beta  = 0.01070044 
#&gt;     gamma = 0.3995392 
#&gt; 
#&gt;   Initial states:
#&gt;      l[0]     b[0]      s[0]     s[-1]    s[-2]    s[-3]    s[-4]    s[-5]    s[-6]     s[-7]    s[-8]    s[-9]    s[-10]    s[-11]
#&gt;  122.3754 1.107367 0.9000411 0.7826691 0.901368 1.047618 1.153707 1.183031 1.083995 0.9786589 1.033162 1.080757 0.9522479 0.9027453
#&gt; 
#&gt;   sigma^2:  0.0016
#&gt; 
#&gt;      AIC     AICc      BIC 
#&gt; 1398.807 1403.664 1449.294
```

]


---

# Model selection

Fortunately for us, the `ETS()` function will deliver the model specification that .hi-blue[minimizes] the .hi-red[corrected AIC].

  - Of course, when we do not specify a model ourselves.
  

--

&lt;br&gt;


```r
air_pass_ets &lt;- air_ts |&gt; 
  model(ETS_best_model = ETS(passengers))

air_pass_ets
```

```
#&gt; # A mable: 1 x 1
#&gt;   ETS_best_model
#&gt;          &lt;model&gt;
*#&gt; 1  &lt;ETS(M,Ad,M)&gt;
```

---

# Model selection

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-15-1.svg" style="display: block; margin: auto;" /&gt;




---

# Model selection

&lt;img src="008-ets-2_files/figure-html/unnamed-chunk-16-1.svg" style="display: block; margin: auto;" /&gt;



---
layout: false
class: inverse, middle

# Next time: ARIMA models

---
exclude: true





    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
